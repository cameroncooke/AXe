name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to build (e.g., v1.0.43)'
        required: false
        type: string
      tap_repo:
        description: 'Homebrew tap repo (owner/name). Leave blank to skip tap update.'
        required: false
        type: string
        default: ''
      tap_target:
        description: 'Tap target(s): production, staging, both, skip (comma-separated). Default chooses staging for prerelease, production otherwise.'
        required: false
        type: string
        default: ''
      tap_formula:
        description: 'Homebrew formula name'
        required: false
        type: string
        default: 'axe'
      tap_branch:
        description: 'Homebrew tap branch'
        required: false
        type: string
        default: 'main'
      staging_tap_repo:
        description: 'Staging Homebrew tap repo (owner/name)'
        required: false
        type: string
        default: 'cameroncooke/axe-staging'
      staging_tap_formula:
        description: 'Staging Homebrew formula name'
        required: false
        type: string
        default: 'axe'
      staging_tap_branch:
        description: 'Staging Homebrew tap branch'
        required: false
        type: string
        default: 'main'
      create_release:
        description: 'Create a GitHub release on manual runs'
        required: false
        type: boolean
        default: false
      prerelease:
        description: 'Mark manual releases as prerelease'
        required: false
        type: boolean
        default: true

env:
  ARCHIVE_NAME: AXe-macOS # Name for the release archive

permissions:
  contents: write
  actions: read

jobs:
  build-and-release:
    runs-on: macos-latest

    outputs:
      archive_name: ${{ steps.create_archive.outputs.archive_name }}
      archive_sha256: ${{ steps.create_archive.outputs.sha256 }}
      homebrew_archive_name: ${{ steps.create_homebrew_archive.outputs.archive_name }}
      homebrew_archive_sha256: ${{ steps.create_homebrew_archive.outputs.sha256 }}
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      package_path: ${{ steps.notarize.outputs.package_path }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Install dependencies
      run: |
        brew install jq

    - name: Extract version from tag
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          if [ -n "${{ github.event.inputs.tag }}" ]; then
            TAG="${{ github.event.inputs.tag }}"
          else
            TAG=$(git describe --tags --abbrev=0)
          fi
          echo "Using tag from manual trigger: $TAG"
        else
          TAG=${GITHUB_REF#refs/tags/}
          echo "Using tag from push event: $TAG"
        fi

        VERSION=${TAG#v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Building version: $VERSION"

    - name: Restore idb repository cache
      uses: actions/cache/restore@v4
      with:
        path: idb_checkout
        key: idb-repo-${{ runner.os }}-dummy
        restore-keys: |
          idb-repo-${{ runner.os }}-

    - name: Check IDB repository freshness
      id: idb_check
      run: |
        set -e

        # Get latest remote commit
        REMOTE_COMMIT=$(git ls-remote https://github.com/facebook/idb.git HEAD | cut -f1)
        echo "Latest IDB commit on remote: $REMOTE_COMMIT"

        if [ -d "idb_checkout" ] && [ -d "idb_checkout/.git" ]; then
          # We have a cached repo, check if it's up to date
          LOCAL_COMMIT=$(git -C idb_checkout rev-parse HEAD)
          echo "Cached IDB commit: $LOCAL_COMMIT"

          if [ "$LOCAL_COMMIT" = "$REMOTE_COMMIT" ]; then
            echo "‚úÖ Cached IDB repository is up to date"
            echo "needs_setup=false" >> $GITHUB_OUTPUT
          else
            echo "üîÑ Cached IDB repository is outdated, needs refresh"
            echo "needs_setup=true" >> $GITHUB_OUTPUT
          fi
        else
          # No cached repo or invalid cache
          echo "üì• No cached IDB repository found, needs setup"
          echo "needs_setup=true" >> $GITHUB_OUTPUT
        fi

        # Always output the remote commit for cache keys
        echo "idb_commit=$REMOTE_COMMIT" >> $GITHUB_OUTPUT

    - name: Setup - Clone IDB repository
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: |
        chmod +x scripts/build.sh
        scripts/build.sh setup

    - name: Make build script executable
      run: chmod +x scripts/build.sh

    # Build Script Steps - Only needed if IDB was updated
    - name: Clean - Remove previous build artifacts
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: scripts/build.sh clean

    - name: Build - IDB Frameworks
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: scripts/build.sh frameworks

    - name: Install - Copy frameworks to build directory
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: scripts/build.sh install

    - name: Strip - Remove nested frameworks
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: scripts/build.sh strip

    # Code Signing Setup
    - name: Setup - Import code signing certificate
      env:
        DEVELOPER_ID_APPLICATION_P12: ${{ secrets.DEVELOPER_ID_APPLICATION_P12 }}
        DEVELOPER_ID_APPLICATION_PASSWORD: ${{ secrets.DEVELOPER_ID_APPLICATION_PASSWORD }}
      run: |
        set -e
        if [ -z "$DEVELOPER_ID_APPLICATION_P12" ]; then
          echo "‚ö†Ô∏è No certificate provided - builds will be unsigned"
          exit 0
        fi

        echo "üîê Setting up code signing certificate..."
        KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
        KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

        # Create and configure keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        # Import certificate
        echo "$DEVELOPER_ID_APPLICATION_P12" | base64 --decode > "$RUNNER_TEMP/certificate.p12"
        if [ -z "$DEVELOPER_ID_APPLICATION_PASSWORD" ]; then
          security import "$RUNNER_TEMP/certificate.p12" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
        else
          security import "$RUNNER_TEMP/certificate.p12" -P "$DEVELOPER_ID_APPLICATION_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
        fi

        # Configure keychain
        security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        echo "‚úÖ Code signing certificate imported successfully"

    - name: Setup - Prepare notarization API key
      env:
        NOTARIZE_APP_STORE_CONNECT_API_KEY: ${{ secrets.NOTARIZE_APP_STORE_CONNECT_API_KEY }}
      run: |
        set -e
        if [ -z "$NOTARIZE_APP_STORE_CONNECT_API_KEY" ]; then
          echo "‚ùå ERROR: Notarization API key is required but not provided"
          echo "Please set NOTARIZE_APP_STORE_CONNECT_API_KEY secret in repository settings"
          exit 1
        fi

        echo "üîë Setting up notarization API key..."
        mkdir -p keys
        echo "$NOTARIZE_APP_STORE_CONNECT_API_KEY" | base64 --decode > keys/AuthKey_${{ secrets.NOTARIZE_APP_STORE_CONNECT_API_KEY_ID }}.p8
        echo "‚úÖ Notarization API key prepared"

    - name: Sign - Framework binaries
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: scripts/build.sh sign-frameworks

    - name: Create - XCFrameworks
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: scripts/build.sh xcframeworks

    - name: Sign - XCFramework bundles
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: scripts/build.sh sign-xcframeworks

    - name: Commit updated XCFrameworks
      if: steps.idb_check.outputs.needs_setup == 'true'
      run: |
        set -e

        echo "üîÑ Committing updated XCFrameworks to repository..."

        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

        # Add the XCFrameworks directory
        git add build_products/XCFrameworks/

        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "‚ÑπÔ∏è No changes to XCFrameworks detected, skipping commit"
        else
          git commit -m "Update XCFrameworks to IDB commit ${{ steps.idb_check.outputs.idb_commit }}"

          # Push to the main branch
          git push origin HEAD:main
          echo "‚úÖ XCFrameworks committed and pushed successfully"
        fi

    - name: Save IDB repository cache
      if: steps.idb_check.outputs.needs_setup == 'true'
      uses: actions/cache/save@v4
      with:
        path: idb_checkout
        key: idb-repo-${{ runner.os }}-${{ steps.idb_check.outputs.idb_commit }}

    - name: Prepare - Clean Swift build environment
      run: |
        echo "üßπ Cleaning Swift build environment..."
        rm -rf .build
        rm -rf ~/Library/Developer/Xcode/DerivedData/*
        echo "‚úÖ Swift build environment cleaned"

    - name: Build - AXe executable
      env:
        SWIFT_DETERMINISTIC_HASHING: 1
        HOMEBREW_NO_AUTO_UPDATE: 1
        CI_BUILD: "true"
        TMPDIR: "/tmp"
        TMP: "/tmp"
        TEMP: "/tmp"
        XDG_CACHE_HOME: "/tmp"
        CLANG_MODULE_CACHE_PATH: "/tmp/clang-modules"
        SWIFT_MODULE_CACHE_PATH: "/tmp/swift-modules"
      run: scripts/build.sh executable

    - name: Sign - AXe executable
      run: scripts/build.sh sign-executable

    - name: Package - Create notarization package
      run: scripts/build.sh package

    - name: Notarize - Submit to Apple for notarization
      id: notarize
      env:
        NOTARIZATION_API_KEY_PATH: keys/AuthKey_${{ secrets.NOTARIZE_APP_STORE_CONNECT_API_KEY_ID }}.p8
        NOTARIZATION_KEY_ID: ${{ secrets.NOTARIZE_APP_STORE_CONNECT_API_KEY_ID }}
        NOTARIZATION_ISSUER_ID: ${{ secrets.NOTARIZE_APP_STORE_CONNECT_ISSUER_ID }}
        TEMP_DIR: ${{ runner.temp }}
      run: |
        scripts/build.sh notarize
        # The notarization step outputs the package path - we need to capture it
        PACKAGE_PATH=$(find "$RUNNER_TEMP" -name "AXe-Final-*.zip" | head -1)
        if [ -n "$PACKAGE_PATH" ]; then
          echo "package_path=$PACKAGE_PATH" >> $GITHUB_OUTPUT
          echo "üì¶ Final package location: $PACKAGE_PATH"
        else
          echo "‚ùå Could not find final package"
          exit 1
        fi

    - name: Create release archive
      id: create_archive
      run: |
        ARCHIVE_NAME="${{ env.ARCHIVE_NAME }}-${{ steps.version.outputs.tag }}.tar.gz"
        echo "archive_name=$ARCHIVE_NAME" >> $GITHUB_OUTPUT

        PACKAGE_PATH="${{ steps.notarize.outputs.package_path }}"
        if [ -f "$PACKAGE_PATH" ]; then
          echo "üì¶ Creating release archive from: $PACKAGE_PATH"

          # Extract the package to create the tar.gz
          TEMP_EXTRACT="$RUNNER_TEMP/extract"
          mkdir -p "$TEMP_EXTRACT"
          unzip -q "$PACKAGE_PATH" -d "$TEMP_EXTRACT"

          # Create tar.gz from extracted contents
          tar -czf "$ARCHIVE_NAME" -C "$TEMP_EXTRACT" .

          # Calculate SHA256
          SHA256=$(shasum -a 256 "$ARCHIVE_NAME" | awk '{print $1}')
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "‚úÖ Archive created: $ARCHIVE_NAME (SHA256: $SHA256)"
        else
          echo "‚ùå Package path not found: $PACKAGE_PATH"
          exit 1
        fi

    - name: Create Homebrew archive (unsigned)
      id: create_homebrew_archive
      run: |
        ARCHIVE_NAME="AXe-macOS-homebrew-${{ steps.version.outputs.tag }}.tar.gz"
        echo "archive_name=$ARCHIVE_NAME" >> $GITHUB_OUTPUT

        PACKAGE_PATH="${{ steps.notarize.outputs.package_path }}"
        if [ -f "$PACKAGE_PATH" ]; then
          echo "üç∫ Creating Homebrew archive from: $PACKAGE_PATH"

          # Extract the package to create the tar.gz
          TEMP_EXTRACT="$RUNNER_TEMP/extract-homebrew"
          mkdir -p "$TEMP_EXTRACT"
          unzip -q "$PACKAGE_PATH" -d "$TEMP_EXTRACT"

          TOP_LEVEL_DIR_COUNT=$(find "$TEMP_EXTRACT" -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')
          TOP_LEVEL_FILE_COUNT=$(find "$TEMP_EXTRACT" -mindepth 1 -maxdepth 1 -type f | wc -l | tr -d ' ')
          if [ "$TOP_LEVEL_DIR_COUNT" -eq 1 ] && [ "$TOP_LEVEL_FILE_COUNT" -eq 0 ]; then
            PACKAGE_ROOT=$(find "$TEMP_EXTRACT" -mindepth 1 -maxdepth 1 -type d | head -1)
          else
            PACKAGE_ROOT="$TEMP_EXTRACT"
          fi

          # Remove signatures so Homebrew can adjust install names/rpaths
          while IFS= read -r -d '' file; do
            if file "$file" | grep -q "Mach-O"; then
              codesign --remove-signature "$file" 2>/dev/null || true
            fi
          done < <(find "$TEMP_EXTRACT" -type f -print0)

          find "$TEMP_EXTRACT" -type d -name "*.framework" -print0 | while IFS= read -r -d '' bundle; do
            codesign --remove-signature "$bundle" 2>/dev/null || true
          done

          # Create tar.gz from extracted contents
          tar -czf "$ARCHIVE_NAME" -C "$PACKAGE_ROOT" .

          # Calculate SHA256
          SHA256=$(shasum -a 256 "$ARCHIVE_NAME" | awk '{print $1}')
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "‚úÖ Homebrew archive created: $ARCHIVE_NAME (SHA256: $SHA256)"
        else
          echo "‚ùå Package path not found: $PACKAGE_PATH"
          exit 1
        fi

    - name: Upload build artifact (manual trigger)
      if: github.event_name == 'workflow_dispatch'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.create_archive.outputs.archive_name }}
        path: ${{ steps.create_archive.outputs.archive_name }}
        retention-days: 30

    - name: Upload Homebrew artifact (manual trigger)
      if: github.event_name == 'workflow_dispatch'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.create_homebrew_archive.outputs.archive_name }}
        path: ${{ steps.create_homebrew_archive.outputs.archive_name }}
        retention-days: 30

    - name: Read tag release notes
      if: github.event_name == 'push'
      id: release_notes
      run: |
        TAG="${{ steps.version.outputs.tag }}"
        git fetch --tags --force
        NOTES=$(git tag -l --format='%(contents)' "$TAG")
        printf '%s\n' "$NOTES" > release-notes.md
        echo "file=release-notes.md" >> $GITHUB_OUTPUT

    - name: Create GitHub release
      if: github.event_name == 'push'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG="${{ steps.version.outputs.tag }}"
        TITLE="Release $TAG"
        NOTES_FILE="${{ steps.release_notes.outputs.file }}"
        VERSION="${{ steps.version.outputs.version }}"

        if [[ "$VERSION" == *"-"* ]]; then
          PRERELEASE_FLAG="--prerelease"
        else
          PRERELEASE_FLAG=""
        fi

        if gh release view "$TAG" >/dev/null 2>&1; then
          echo "üóëÔ∏è Existing release found for $TAG. Deleting..."
          gh release delete "$TAG" --yes
        fi

        gh release create "$TAG" \
          --title "$TITLE" \
          --notes-file "$NOTES_FILE" \
          $PRERELEASE_FLAG \
          "${{ steps.create_archive.outputs.archive_name }}" \
          "${{ steps.create_homebrew_archive.outputs.archive_name }}"

        echo "‚úÖ Release $TAG created."

    - name: Create GitHub release (manual trigger)
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG="${{ steps.version.outputs.tag }}"
        TITLE="Release $TAG"
        VERSION="${{ steps.version.outputs.version }}"

        if [[ "${{ github.event.inputs.prerelease }}" == "true" || "$VERSION" == *"-"* ]]; then
          PRERELEASE_FLAG="--prerelease"
        else
          PRERELEASE_FLAG=""
        fi

        if gh release view "$TAG" >/dev/null 2>&1; then
          echo "üóëÔ∏è Existing release found for $TAG. Deleting..."
          gh release delete "$TAG" --yes
        fi

        gh release create "$TAG" \
          --title "$TITLE" \
          --generate-notes \
          $PRERELEASE_FLAG \
          "${{ steps.create_archive.outputs.archive_name }}" \
          "${{ steps.create_homebrew_archive.outputs.archive_name }}"

        echo "‚úÖ Release $TAG created (manual trigger)."

    - name: Update Homebrew tap(s)
      if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
      env:
        HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        HOMEBREW_STAGING_TAP_TOKEN: ${{ secrets.HOMEBREW_STAGING_TAP_TOKEN }}
      run: |
        set -e
        VERSION_TAG="${{ steps.version.outputs.version }}"

        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          TAP_TARGETS="${{ github.event.inputs.tap_target }}"
          if [ -z "$TAP_TARGETS" ]; then
            if [ "${{ github.event.inputs.create_release }}" = "true" ] && [[ "$VERSION_TAG" != *"-"* ]]; then
              TAP_TARGETS="production"
            else
              TAP_TARGETS="staging"
            fi
          fi
        else
          if [[ "$VERSION_TAG" == *"-"* ]]; then
            TAP_TARGETS="staging"
          else
            TAP_TARGETS="production"
          fi
        fi

        if [ -z "$TAP_TARGETS" ]; then
          echo "‚ÑπÔ∏è Homebrew tap update skipped - no targets requested"
          exit 0
        fi

        # Normalize shorthand
        if [[ "$TAP_TARGETS" == "both" ]]; then
          TAP_TARGETS="production,staging"
        fi

        IFS=',' read -ra TARGETS <<< "$TAP_TARGETS"
        for TARGET in "${TARGETS[@]}"; do
          TARGET=$(echo "$TARGET" | tr -d '[:space:]')
          case "$TARGET" in
            production|"")
              TAP_REPO="${{ github.event.inputs.tap_repo }}"
              TAP_FORMULA="${{ github.event.inputs.tap_formula }}"
              TAP_BRANCH="${{ github.event.inputs.tap_branch }}"
              TAP_REPO="${TAP_REPO:-cameroncooke/homebrew-axe}"
              TAP_FORMULA="${TAP_FORMULA:-axe}"
              TAP_BRANCH="${TAP_BRANCH:-main}"
              TOKEN="$HOMEBREW_TAP_TOKEN"
              FRIENDLY_NAME="production"
              ;;
            staging)
              TAP_REPO="${{ github.event.inputs.staging_tap_repo }}"
              TAP_FORMULA="${{ github.event.inputs.staging_tap_formula }}"
              TAP_BRANCH="${{ github.event.inputs.staging_tap_branch }}"
              TAP_REPO="${TAP_REPO:-cameroncooke/axe-staging}"
              TAP_FORMULA="${TAP_FORMULA:-axe}"
              TAP_BRANCH="${TAP_BRANCH:-main}"
              TOKEN="${HOMEBREW_STAGING_TAP_TOKEN:-$HOMEBREW_TAP_TOKEN}"
              FRIENDLY_NAME="staging"
              ;;
            skip)
              echo "‚ÑπÔ∏è Homebrew tap update skipped by request (target=skip)"
              continue
              ;;
            *)
              echo "‚ö†Ô∏è Unknown tap target '$TARGET' - skipping"
              continue
              ;;
          esac

          if [ -z "$TOKEN" ]; then
            echo "‚ö†Ô∏è Homebrew tap update skipped for $FRIENDLY_NAME ($TAP_REPO) - no token provided"
            continue
          fi

          echo "üç∫ Updating Homebrew tap (${FRIENDLY_NAME}): ${TAP_REPO} [branch=${TAP_BRANCH}, formula=${TAP_FORMULA}]"

          WORK_DIR="tap-repo-${TARGET}"
          rm -rf "$WORK_DIR"
          GH_TOKEN="$TOKEN" gh repo clone "${TAP_REPO}" "$WORK_DIR"
          cd "$WORK_DIR"
          git checkout "${TAP_BRANCH}"

          FORMULA_FILE="Formula/${TAP_FORMULA}.rb"
          if [ ! -f "$FORMULA_FILE" ]; then
            echo "‚ùå Formula file not found: $FORMULA_FILE"
            exit 1
          fi

          URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/${{ steps.create_homebrew_archive.outputs.archive_name }}"
          SHA256="${{ steps.create_homebrew_archive.outputs.sha256 }}"

          awk -v version="$VERSION_TAG" -v url="$URL" -v sha="$SHA256" '
          /version "/ {gsub(/version "[^"]*"/, "version \"" version "\""); print; next}
          /url "/ {gsub(/url "[^"]*"/, "url \"" url "\""); print; next}
          /sha256 "/ {gsub(/sha256 "[^"]*"/, "sha256 \"" sha "\""); print; next}
          {print}
          ' "$FORMULA_FILE" > "${FORMULA_FILE}.new" && mv "${FORMULA_FILE}.new" "$FORMULA_FILE"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$FORMULA_FILE"
          if ! git diff --staged --quiet; then
            git commit -m "Update axe to v${VERSION_TAG}"
            GH_TOKEN="$TOKEN" git push origin "${TAP_BRANCH}"
            echo "‚úÖ Homebrew formula updated successfully to v${VERSION_TAG} (${FRIENDLY_NAME})"
          else
            echo "‚ÑπÔ∏è No changes to commit for Homebrew formula (v${VERSION_TAG})"
          fi

          cd ..
        done

    - name: Cleanup
      if: always()
      run: |
        echo "üßπ Cleaning up sensitive files..."
        rm -rf keys/
        rm -f "$RUNNER_TEMP"/*.p12
        echo "‚úÖ Cleanup completed"
